function[K,S]=doubleo(A,G,Q,R)%function[K,S]=doubleo(A,G,Q,R)%  This program uses the "doubling algorithm" to solve the%  Riccati matrix difference equations associated with the%  Kalman filter.  A is nxn, C is kxn, Q is nxn, R is kxk.%  The program returns the gain K and the stationary covariance%  matrix of the one-step ahead errors in forecasting the state.%  The program creates the Kalman filter for the following system:%       x(t+1) = A * x(t) + e(t+1)%         y(t) = G * x(t) + v(t)%  where E e(t+1)*e(t+1)' =  Q, and E v(t)*v(t)' = R, and v(s) is orthogonal%  to e(t) for all t and s.  The program creates the observer system%        xx(t+1) = A * xx(t) + K * a(t)%           y(t) = G * xx(t) + a(t),%  where K is the Kalman gain ,S = E (x(t) - xx(t))*(x(t) - xx(t))', and%  a(t) = y(t) - E[y(t)| y(t-1), y(t-2), ... ], and xx(t)=E[x(t)|y(t-1),...].%  NOTE:  By using DUALITY, control problems can also be solved.a0 = A';b0 = G'*(R\G);sigma_t = Q;EA = eye(size(A));dif = 1;iter = 0;while dif > 1e-8    a1 = a0 *((EA+b0*sigma_t)\a0);    b1 = b0+a0*((EA+b0*sigma_t)\(b0*a0'));    sigma_t1 = sigma_t+a0'*sigma_t*((EA+b0*sigma_t)\a0);    K1 = A*sigma_t1*G'/(G*sigma_t1*G'+R);    K0 = A*sigma_t*G'/(G*sigma_t*G'+R);    dif = max(max(abs(K1-K0)));    a0 = a1;    b0 = b1;    sigma_t = sigma_t1;    iter = iter+1;endif iter >= 1000    disp('WARNING: Iteration limit of 1000 reached in doubleo.m'); endK = K1;S = sigma_t1;iter;